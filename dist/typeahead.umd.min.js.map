{"version":3,"file":"typeahead.umd.min.js","sources":["../node_modules/bind-decorator/index.js","../src/accessor.ts","../node_modules/classnames/index.js","../src/typeahead/option.tsx","../src/typeahead/selector.tsx","../src/keyevent.ts","../node_modules/fuzzy/lib/fuzzy.js","../src/typeahead/index.tsx","../src/tokenizer/token.tsx","../src/tokenizer/index.tsx"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants;\n(function (constants) {\n    constants.typeOfFunction = 'function';\n    constants.boolTrue = true;\n})(constants || (constants = {}));\nfunction bind(target, propertyKey, descriptor) {\n    if (!descriptor || (typeof descriptor.value !== constants.typeOfFunction)) {\n        throw new TypeError(\"Only methods can be decorated with @bind. <\" + propertyKey + \"> is not a method!\");\n    }\n    return {\n        configurable: constants.boolTrue,\n        get: function () {\n            var bound = descriptor.value.bind(this);\n            // Credits to https://github.com/andreypopp/autobind-decorator for memoizing the result of bind against a symbol on the instance.\n            Object.defineProperty(this, propertyKey, {\n                value: bound,\n                configurable: constants.boolTrue,\n                writable: constants.boolTrue\n            });\n            return bound;\n        }\n    };\n}\nexports.bind = bind;\nexports.default = bind;\n","import { OptionToStrFn, Option } from './types';\n\nexport default class Accessor {\n  // tslint:disable-next-line\n  static IDENTITY_FN<T>(input: T): T { return input; }\n\n  static generateAccessor(field: string) {\n    return (object: { [propName: string]: string }) => object[field];\n  }\n\n  static generateOptionToStringFor<T>(prop?: string | Function): OptionToStrFn<T> {\n    if (typeof prop === 'string') {\n      // @ts-ignore\n      return Accessor.generateAccessor(prop);\n    } \n    \n    if (typeof prop === 'function') {\n      return (prop as any);\n    }\n    \n    return function (input: any) { return (input as string); };\n  }\n\n  static valueForOption<T extends Option>(\n    object: T,\n    selector?: string | OptionToStrFn<T> | undefined, \n  ): string | void {\n    if (typeof selector === 'string') {\n      if (typeof object !== 'object') throw new Error(`Invalid object type ${typeof object}`);\n      // @ts-ignore\n      return object[selector];\n    } \n    \n    if (typeof selector === 'function') {\n      return selector(object);\n    }\n\n    if (typeof object === 'string') {\n      return object;\n    }\n    \n    throw new Error(`Invalid object type ${typeof object}`);\n  }\n}\n","/*!\n  Copyright (c) 2016 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tclasses.push(classNames.apply(null, arg));\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import * as React from 'react';\nimport classNames from 'classnames';\n\nexport interface CustomClasses {\n  listItem?: string;\n  hover?: string;\n  customAdd?: string;\n  listAnchor?: string;\n}\n\nexport interface Props {\n  customClasses?: CustomClasses;\n  customValue?: string;\n  onClick: Function;\n  children: React.ReactNode;\n  hover?: boolean;\n}\n\n/**\n * A single option within the TypeaheadSelector\n */\nclass TypeaheadOption extends React.Component<Props> {\n  constructor(props: Props) {\n    super(props);\n\n    this.onClick = this.onClick.bind(this);\n  }\n\n  private getProps() {\n    const customClasses: CustomClasses = { hover: 'hover' };\n    return {\n      ...{\n        customClasses,\n        onClick: (event: React.MouseEvent<HTMLDivElement>) => {\n          event.preventDefault();\n        },\n        hover: false,\n      },\n      ...this.props,\n    };\n  }\n\n  render() {\n    const { \n      customClasses, hover,\n      children, customValue,\n     } = this.getProps();\n\n    const classes: any = { };\n    const { listItem, hover: hoverClass = 'hover', customAdd } = customClasses;\n    classes[hoverClass] = Boolean(hover);\n    if (listItem) {\n      classes[listItem] = Boolean(listItem);\n    }\n\n    if (customValue && customAdd) {\n      classes[customAdd] = Boolean(customAdd);\n    }\n\n    const classList = classNames(classes);\n\n    // For some reason onClick is not fired when clicked on an option\n    // onMouseDown is used here as a workaround of #205 and other\n    // related tickets\n    return (\n      <li className={classList} onClick={this.onClick} onMouseDown={this.onClick}>\n        <a \n          href=\"javascript: void 0;\" \n          className={this.getClasses()} \n        >\n          {children}\n        </a>\n      </li>\n    );\n  }\n\n  getClasses() {\n    const { customClasses } = this.getProps();\n    const classes: any = {\n      'typeahead-option': true,\n    };\n    const { listAnchor } = customClasses;\n    if (listAnchor) {\n      classes[listAnchor] = true;\n    }\n\n    return classNames(classes);\n  }\n\n  onClick(event: React.MouseEvent<HTMLLIElement>) {\n    event.preventDefault();\n    return this.props.onClick(event);\n  }\n}\n\nexport default TypeaheadOption;\n","import * as React from 'react';\nimport classNames from 'classnames';\nimport TypeaheadOption from './option';\nimport { CustomClasses, OptionSelector, Option } from '../types';\n\nexport interface Props<Opt extends Option> {\n  options: Opt[];\n  allowCustomValues?: number;\n  customClasses?: CustomClasses;\n  customValue?: string;\n  selectionIndex?: number;\n  onOptionSelected?: OptionSelector;\n  displayOption: Function;\n  defaultClassNames?: boolean;\n  areResultsTruncated?: boolean;\n  resultsTruncatedMessage?: string;\n  innerRef?: ((c: HTMLElement) => void);\n}\n\n/**\n * Container for the options rendered as part of the autocompletion process\n * of the typeahead\n */\nclass TypeaheadSelector<T> extends React.Component<Props<T>> {\n  // Hack to handle the buggy typescript defaultProps\n  private getProps() {\n    const customClasses: CustomClasses = {};\n    return {\n      ...{\n        customClasses,\n        allowCustomValues: 0,\n        onOptionSelected: () => {},\n        defaultClassNames: true,\n      },\n      ...this.props,\n    };\n  }\n\n  render() {\n    const { \n      options, customClasses, customValue, displayOption,\n      defaultClassNames, allowCustomValues, selectionIndex,\n      areResultsTruncated, resultsTruncatedMessage,\n    } = this.getProps();\n    // Don't render if there are no options to display\n    if (!options.length && allowCustomValues <= 0) {\n      return false;\n    }\n\n    const classes: any = {\n      'typeahead-selector': defaultClassNames,\n    };\n    const { results: resClass } = customClasses;\n    if (resClass) {\n      classes[resClass] = true;\n    }\n    const classList = classNames(classes);\n\n    // CustomValue should be added to top of results list with different class name\n    let customValueComponent;\n    let customValueOffset = 0;\n    if (customValue) {\n      customValueOffset += 1;\n      // TODO: needed ref? ref={customValue} \n      customValueComponent = (\n        <TypeaheadOption \n          key={customValue}\n          hover={selectionIndex === 0}\n          customClasses={customClasses}\n          customValue={customValue}\n          onClick={this.onClick.bind(this, customValue)}\n        >\n          {customValue}\n        </TypeaheadOption>\n      );\n    }\n\n    const results = options.map((result, i) => {\n      const displayString = displayOption(result, i);\n      const uniqueKey = displayString + '_' + i;\n      // TODO: needed ref? ref={uniqueKey} \n      return (\n        <TypeaheadOption \n          key={uniqueKey}\n          hover={selectionIndex === i + customValueOffset}\n          customClasses={customClasses}\n          onClick={this.onClick.bind(this, result)}\n        >\n          {displayString}\n        </TypeaheadOption>\n      );\n    });\n\n    if (areResultsTruncated && resultsTruncatedMessage) {\n      const resultsTruncatedClasses: any = {\n        'results-truncated': true,\n      };\n      const { resultsTruncated } = customClasses;\n      if (resultsTruncated) {\n        resultsTruncatedClasses[resultsTruncated] = true;\n      }\n      const resultsTruncatedClassList = classNames(resultsTruncatedClasses);\n\n      results.push(\n        <li key=\"results-truncated\" className={resultsTruncatedClassList}>\n          {this.props.resultsTruncatedMessage}\n        </li>);\n    }\n    \n    return (\n      <ul className={classList}>\n        {customValueComponent}\n        {results}\n      </ul>\n    );\n  }\n\n  private onClick(result: string, event: React.MouseEvent<HTMLDivElement>) {\n    const { onOptionSelected } = this.props;\n    if (!onOptionSelected) return;\n\n    return onOptionSelected(result, event);\n  }\n}\n\nexport default TypeaheadSelector;\n","/**\n * PolyFills make me sad\n */\n// @ts-ignore\nconst KeyEvent: { [propName: string]: number } = KeyEvent || {};\nKeyEvent.DOM_VK_UP = KeyEvent.DOM_VK_UP || 38;\nKeyEvent.DOM_VK_DOWN = KeyEvent.DOM_VK_DOWN || 40;\nKeyEvent.DOM_VK_BACK_SPACE = KeyEvent.DOM_VK_BACK_SPACE || 8;\nKeyEvent.DOM_VK_RETURN = KeyEvent.DOM_VK_RETURN || 13;\nKeyEvent.DOM_VK_ENTER = KeyEvent.DOM_VK_ENTER || 14;\nKeyEvent.DOM_VK_ESCAPE = KeyEvent.DOM_VK_ESCAPE || 27;\nKeyEvent.DOM_VK_TAB = KeyEvent.DOM_VK_TAB || 9;\n\nexport default KeyEvent;\n","/*\n * Fuzzy\n * https://github.com/myork/fuzzy\n *\n * Copyright (c) 2012 Matt York\n * Licensed under the MIT license.\n */\n\n(function() {\n\nvar root = this;\n\nvar fuzzy = {};\n\n// Use in node or in browser\nif (typeof exports !== 'undefined') {\n  module.exports = fuzzy;\n} else {\n  root.fuzzy = fuzzy;\n}\n\n// Return all elements of `array` that have a fuzzy\n// match against `pattern`.\nfuzzy.simpleFilter = function(pattern, array) {\n  return array.filter(function(str) {\n    return fuzzy.test(pattern, str);\n  });\n};\n\n// Does `pattern` fuzzy match `str`?\nfuzzy.test = function(pattern, str) {\n  return fuzzy.match(pattern, str) !== null;\n};\n\n// If `pattern` matches `str`, wrap each matching character\n// in `opts.pre` and `opts.post`. If no match, return null\nfuzzy.match = function(pattern, str, opts) {\n  opts = opts || {};\n  var patternIdx = 0\n    , result = []\n    , len = str.length\n    , totalScore = 0\n    , currScore = 0\n    // prefix\n    , pre = opts.pre || ''\n    // suffix\n    , post = opts.post || ''\n    // String to compare against. This might be a lowercase version of the\n    // raw string\n    , compareString =  opts.caseSensitive && str || str.toLowerCase()\n    , ch;\n\n  pattern = opts.caseSensitive && pattern || pattern.toLowerCase();\n\n  // For each character in the string, either add it to the result\n  // or wrap in template if it's the next string in the pattern\n  for(var idx = 0; idx < len; idx++) {\n    ch = str[idx];\n    if(compareString[idx] === pattern[patternIdx]) {\n      ch = pre + ch + post;\n      patternIdx += 1;\n\n      // consecutive characters should increase the score more than linearly\n      currScore += 1 + currScore;\n    } else {\n      currScore = 0;\n    }\n    totalScore += currScore;\n    result[result.length] = ch;\n  }\n\n  // return rendered string if we have a match for every char\n  if(patternIdx === pattern.length) {\n    // if the string is an exact match with pattern, totalScore should be maxed\n    totalScore = (compareString === pattern) ? Infinity : totalScore;\n    return {rendered: result.join(''), score: totalScore};\n  }\n\n  return null;\n};\n\n// The normal entry point. Filters `arr` for matches against `pattern`.\n// It returns an array with matching values of the type:\n//\n//     [{\n//         string:   '<b>lah' // The rendered string\n//       , index:    2        // The index of the element in `arr`\n//       , original: 'blah'   // The original element in `arr`\n//     }]\n//\n// `opts` is an optional argument bag. Details:\n//\n//    opts = {\n//        // string to put before a matching character\n//        pre:     '<b>'\n//\n//        // string to put after matching character\n//      , post:    '</b>'\n//\n//        // Optional function. Input is an entry in the given arr`,\n//        // output should be the string to test `pattern` against.\n//        // In this example, if `arr = [{crying: 'koala'}]` we would return\n//        // 'koala'.\n//      , extract: function(arg) { return arg.crying; }\n//    }\nfuzzy.filter = function(pattern, arr, opts) {\n  if(!arr || arr.length === 0) {\n    return [];\n  }\n  if (typeof pattern !== 'string') {\n    return arr;\n  }\n  opts = opts || {};\n  return arr\n    .reduce(function(prev, element, idx, arr) {\n      var str = element;\n      if(opts.extract) {\n        str = opts.extract(element);\n      }\n      var rendered = fuzzy.match(pattern, str, opts);\n      if(rendered != null) {\n        prev[prev.length] = {\n            string: rendered.rendered\n          , score: rendered.score\n          , index: idx\n          , original: element\n        };\n      }\n      return prev;\n    }, [])\n\n    // Sort by score. Browsers are inconsistent wrt stable/unstable\n    // sorting, so force stable by using the index in the case of tie.\n    // See http://ofb.net/~sethml/is-sort-stable.html\n    .sort(function(a,b) {\n      var compare = b.score - a.score;\n      if(compare) return compare;\n      return a.index - b.index;\n    });\n};\n\n\n}());\n\n","import * as React from 'react';\nimport bind from 'bind-decorator';\nimport Accessor from '../accessor';\nimport TypeaheadSelector, { Props as TypelistProps } from './selector';\nimport KeyEvent from '../keyevent';\nimport fuzzy, { FilterOptions } from 'fuzzy';\nimport classNames from 'classnames';\nimport { CustomClasses, Option, OptionToStrFn } from '../types';\n\nexport type OnOptionSelectArg<Opt extends Option> = \n  ((option: Opt | string, event?: React.SyntheticEvent<HTMLAnchorElement>) => any);\n\nexport type AnyReactWithProps<Opt extends Option> = \n  React.Component<TypelistProps<Opt>> | \n  React.PureComponent<TypelistProps<Opt>> |\n  React.SFC<TypelistProps<Opt>>;\n\nexport interface Props<Opt extends Option, Mapped> extends  React.InputHTMLAttributes<HTMLInputElement> {\n  name?: string;\n  customClasses?: CustomClasses;\n  maxVisible?: number;\n  resultsTruncatedMessage?: string;\n  options: Opt[];\n  allowCustomValues?: number;\n  initialValue?: string;\n  value?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  textarea?: boolean;\n  inputProps?: object;\n  onOptionSelected?: OnOptionSelectArg<Mapped>;\n  filterOption?: string | ((value: string, option: Opt) => boolean);\n  searchOptions?: ((value: string, option: Opt[]) => Mapped[]);\n  displayOption?: string | OptionToStrFn<Mapped>;\n  inputDisplayOption?: string | OptionToStrFn<Mapped>;\n  formInputOption?: string | OptionToStrFn<Mapped>;\n  defaultClassNames?: boolean;\n  customListComponent?: AnyReactWithProps<Opt>;\n  showOptionsWhenEmpty?: boolean;\n  innerRef?: (c: HTMLInputElement) => any;\n}\n\nexport interface State<Mapped> {\n  // The options matching the entry value\n  searchResults: Mapped[];\n\n  // This should be called something else, \"entryValue\"\n  entryValue: string;\n\n  // A valid typeahead value\n  selection?: string;\n\n  // Index of the selection\n  selectionIndex?: number;\n\n  // Keep track of the focus state of the input element, to determine\n  // whether to show options when empty (if showOptionsWhenEmpty is true)\n\n  isFocused: boolean;\n  // true when focused, false onOptionSelected\n  showResults: boolean;\n}\n\n/**\n * A \"typeahead\", an auto-completing text input\n *\n * Renders an text input that shows options nearby that you can use the\n * keyboard or mouse to select.  Requires CSS for MASSIVE DAMAGE.\n */\nclass Typeahead<T extends Option, Mapped> extends React.Component<\n  Props<T, Mapped>,\n  State<Mapped>\n> {\n  constructor(props: Props<T, Mapped>) {\n    super(props);\n\n    this.state = {\n      // The options matching the entry value\n      searchResults: this.getOptionsForValue(props.initialValue, props.options),\n\n      // This should be called something else, \"entryValue\"\n      entryValue: props.value || '',\n\n      // A valid typeahead value\n      selection: props.value,\n\n      // Index of the selection\n      selectionIndex: undefined,\n\n      // Keep track of the focus state of the input element, to determine\n      // whether to show options when empty (if showOptionsWhenEmpty is true)\n      isFocused: false,\n\n      // true when focused, false onOptionSelected\n      showResults: false,\n    };\n  }\n\n  public inputElement?: HTMLInputElement;\n\n  // Hack due to buggy defaultprops handling in typescript\n  private getProps() {\n    const customClasses: CustomClasses = {};\n    return {\n      ...{\n        customClasses,\n        allowCustomValues: 0,\n        initialValue: '',\n        value: '',\n        disabled: false,\n        textarea: false,\n        customListComponent: TypeaheadSelector,\n        showOptionsWhenEmpty: false,\n      },\n      ...this.props,\n    };\n  }\n\n  private shouldSkipSearch(input?: string) {\n    const emptyValue = !input || input.trim().length === 0;\n\n    // this.state must be checked because it may not be defined yet if this function\n    // is called from within getInitialState\n    const isFocused = this.state && this.state.isFocused;\n    return !(this.props.showOptionsWhenEmpty && isFocused) && emptyValue;\n  }\n\n  getOptionsForValue(value?: string, options?: T[]): Mapped[] {\n    if (this.shouldSkipSearch(value)) {\n      return [];\n    }\n\n    const searchOptions = this.generateSearchFunction();    \n    return searchOptions(value || '', options || this.getProps().options);\n  }\n\n  setEntryText(value: string) {\n    if (!this.inputElement) return;\n    this.inputElement.value = value;\n    this.onTextEntryUpdated();\n  }\n\n  @bind\n  focus() {\n    if (!this.inputElement) return;\n    this.inputElement.focus();\n  }\n\n  private hasCustomValue() {\n    const { allowCustomValues } = this.getProps();\n    const { entryValue, searchResults } = this.state;\n\n    if (\n      !allowCustomValues ||\n      allowCustomValues > 0 ||\n      entryValue.length >= allowCustomValues\n    ) {\n      return false;\n    }\n\n    const mapper = this.getInputOptionToStringMapper();\n    return searchResults.map(mapper).indexOf(this.state.entryValue) < 0;\n  }\n\n  private getCustomValue() {\n    if (this.hasCustomValue()) {\n      return this.state.entryValue;\n    }\n    return undefined;\n  }\n\n  private renderIncrementalSearchResults() {\n    const { entryValue, selection, searchResults, selectionIndex } = this.state;\n    const {\n      maxVisible,\n      resultsTruncatedMessage,\n      displayOption,\n      allowCustomValues,\n      customClasses,\n      defaultClassNames,\n    } = this.getProps();\n\n    // Nothing has been entered into the textbox\n    if (this.shouldSkipSearch(entryValue)) {\n      return '';\n    }\n\n    // Something was just selected\n    if (selection) {\n      return '';\n    }\n\n    const truncated: boolean = Boolean(\n      maxVisible && searchResults.length > maxVisible,\n    );\n    return (\n      <TypeaheadSelector\n        options={\n          maxVisible ? searchResults.slice(0, maxVisible) : searchResults\n        }\n        areResultsTruncated={truncated}\n        onOptionSelected={this.onOptionSelected}\n        customValue={this.getCustomValue()}\n        displayOption={Accessor.generateOptionToStringFor(displayOption)}\n        {...{\n          allowCustomValues,\n          resultsTruncatedMessage,\n          customClasses,\n          selectionIndex,\n          defaultClassNames,\n        }}\n      />\n    );\n  }\n\n  getSelection(): Mapped | string | undefined {\n    let index = this.state.selectionIndex;\n    if (index === undefined) return undefined;\n\n    if (this.hasCustomValue()) {\n      if (index === 0) {\n        return this.state.entryValue;\n      }\n      index -= 1;\n    }\n\n    return this.state.searchResults[index];\n  }\n\n  private inputMapper?: OptionToStrFn<Mapped>;\n  private getInputOptionToStringMapper(): OptionToStrFn<Mapped> {\n    if (this.inputMapper) {\n      return this.inputMapper;\n    }\n\n    const {\n      formInputOption,\n      inputDisplayOption,\n      displayOption,\n    } = this.getProps();\n    const anyToStrFn = formInputOption || inputDisplayOption || displayOption;\n    this.inputMapper = Accessor.generateOptionToStringFor(anyToStrFn);\n\n    return this.inputMapper;\n  }\n\n  private displayMapper?: OptionToStrFn<Mapped>;\n  private getDisplayOptionToStringMapper(): OptionToStrFn<Mapped> {\n    if (this.displayMapper) {\n      return this.displayMapper;\n    }\n\n    const { displayOption, inputDisplayOption } = this.getProps();\n    this.displayMapper = Accessor.generateOptionToStringFor(\n      inputDisplayOption || displayOption,\n    );\n\n    return this.displayMapper;\n  }\n\n  @bind\n  private onOptionSelected(\n    option: Mapped | string,\n    event: React.SyntheticEvent<any>,\n  ) {\n    if (!this.inputElement) throw new Error('No input element');\n    this.inputElement.focus();\n\n    let optionString: string;\n    let formInputOptionString: string;\n    if (typeof option === 'string') {\n      optionString = option as string;\n      formInputOptionString = option as string;\n    } else {\n      const displayOption = this.getDisplayOptionToStringMapper();\n      optionString = displayOption(option, 0);\n\n      const formInputOption = this.getInputOptionToStringMapper();\n      formInputOptionString = formInputOption(option);\n    }\n\n    this.inputElement.value = optionString;\n    this.setState({\n      searchResults: this.getOptionsForValue(optionString),\n      selection: formInputOptionString,\n      entryValue: optionString,\n      showResults: false,\n    });\n    return (\n      this.props.onOptionSelected && this.props.onOptionSelected(option, event)\n    );\n  }\n\n  @bind\n  private onTextEntryUpdated(newValue?: string) {\n    if (!this.inputElement) throw new Error('No input element');\n    const value = newValue === undefined ? this.inputElement.value : newValue;\n\n    this.setState({\n      searchResults: this.getOptionsForValue(value),\n      selection: '',\n      entryValue: value,\n    });\n  }\n\n  @bind\n  private onEnter(event: React.KeyboardEvent<HTMLInputElement>) {\n    const selection = this.getSelection();\n    if (!selection) {\n      return this.props.onKeyDown && this.props.onKeyDown(event);\n    }\n    return this.onOptionSelected(selection, event);\n  }\n\n  @bind\n  private onEscape() {\n    this.setState({\n      selectionIndex: undefined,\n    });\n  }\n\n  @bind\n  private onTab(event: React.KeyboardEvent<HTMLInputElement>) {\n    const selection = this.getSelection();\n\n    let option = selection\n      ? selection\n      : this.state.searchResults.length > 0\n        ? this.state.searchResults[0]\n        : undefined;\n\n    if (option === undefined && this.hasCustomValue()) {\n      option = this.getCustomValue();\n    }\n\n    if (option !== undefined) {\n      return this.onOptionSelected(option, event);\n    }\n  }\n\n  eventMap() {\n    const events: any = {};\n\n    events[KeyEvent.DOM_VK_UP] = this.navUp;\n    events[KeyEvent.DOM_VK_DOWN] = this.navDown;\n    events[KeyEvent.DOM_VK_RETURN] = events[\n      KeyEvent.DOM_VK_ENTER\n    ] = this.onEnter;\n    events[KeyEvent.DOM_VK_ESCAPE] = this.onEscape;\n    events[KeyEvent.DOM_VK_TAB] = this.onTab;\n\n    return events;\n  }\n\n  private nav(delta: number) {\n    if (!this.hasHint()) {\n      return;\n    }\n\n    const { selectionIndex, searchResults } = this.state;\n    const { maxVisible } = this.getProps();\n    let newIndex =\n      selectionIndex === undefined\n        ? delta === 1\n          ? 0\n          : delta\n        : selectionIndex + delta;\n    let length = maxVisible\n      ? searchResults.slice(0, maxVisible).length\n      : searchResults.length;\n    if (this.hasCustomValue()) {\n      length += 1;\n    }\n\n    if (newIndex < 0) {\n      newIndex += length;\n    } else if (newIndex >= length) {\n      newIndex -= length;\n    }\n\n    this.setState({ selectionIndex: newIndex });\n  }\n\n  @bind\n  navDown() {\n    this.nav(1);\n  }\n\n  @bind\n  navUp() {\n    this.nav(-1);\n  }\n\n  @bind\n  private onChange(event: React.ChangeEvent<HTMLInputElement>) {\n    const { onChange } = this.getProps();\n    if (onChange) {\n      onChange(event);\n    }\n\n    this.onTextEntryUpdated(event.target.value);\n  }\n\n  @bind\n  private onKeyDown(event: React.KeyboardEvent<HTMLInputElement>) {\n    // If there are no visible elements, don't perform selector navigation.\n    // Just pass this up to the upstream onKeydown handler.\n    // Also skip if the user is pressing the shift key,\n    // since none of our handlers are looking for shift\n    if (!this.hasHint() || event.shiftKey) {\n      return this.props.onKeyDown && this.props.onKeyDown(event);\n    }\n\n    const handler = this.eventMap()[event.keyCode];\n    if (handler) {\n      handler(event);\n    } else {\n      return this.props.onKeyDown && this.props.onKeyDown(event);\n    }\n    // Don't propagate the keystroke back to the DOM/browser\n    event.preventDefault();\n  }\n\n  componentWillReceiveProps(nextProps: Props<T, Mapped>) {\n    const searchResults = this.getOptionsForValue(\n      this.state.entryValue,\n      nextProps.options,\n    );\n    const showResults = Boolean(searchResults.length) && this.state.isFocused;\n    this.setState({ searchResults, showResults });\n  }\n\n  render() {\n    const {\n      customClasses: { input },\n      className,\n    } = this.getProps();\n    const inputClasses: any = {};\n    if (input) {\n      inputClasses[input] = true;\n    }\n    const inputClassList = classNames(inputClasses);\n\n    const classes: any = {\n      typeahead: this.props.defaultClassNames,\n    };\n    if (className) {\n      classes[className] = true;\n    }\n    const classList = classNames(classes);\n\n    return (\n      <div className={classList}>\n        {this.renderHiddenInput()}\n        <input\n          ref={(c: HTMLInputElement) => {\n            this.inputElement = c;\n            this.props.innerRef && this.props.innerRef(c);\n          }}\n          type={this.props.textarea ? 'textarea' : 'text'}\n          disabled={this.props.disabled}\n          {...this.props.inputProps}\n          placeholder={this.props.placeholder}\n          className={inputClassList}\n          value={this.state.entryValue}\n          onChange={this.onChange}\n          onKeyDown={this.onKeyDown}\n          onKeyPress={this.props.onKeyPress}\n          onKeyUp={this.props.onKeyUp}\n          onFocus={this.onFocus}\n          onBlur={this.onBlur}\n        />\n        {this.state.showResults && this.renderIncrementalSearchResults()}\n      </div>\n    );\n  }\n\n  @bind\n  private onFocus(event: React.FocusEvent<HTMLInputElement>) {\n    this.setState({ isFocused: true, showResults: true }, () => {\n      this.onTextEntryUpdated();\n    });\n    this.props.onFocus && this.props.onFocus(event);\n  }\n\n  @bind\n  private onBlur(event: React.FocusEvent<HTMLInputElement>) {\n    this.setState({ isFocused: false }, () => {\n      this.onTextEntryUpdated();\n    });\n    this.props.onBlur && this.props.onBlur(event);\n  }\n\n  private renderHiddenInput() {\n    const { name } = this.getProps();\n    if (!name) {\n      return null;\n    }\n\n    return <input type=\"hidden\" name={name} value={this.state.selection} />;\n  }\n\n  private searchFunction?: (value: string, options: T[]) => Mapped[];\n  private generateSearchFunction(): (value: string, options: T[]) => Mapped[] {\n    if (this.searchFunction) {\n      return this.searchFunction;\n    }\n    const { searchOptions, filterOption } = this.getProps();\n    if (typeof searchOptions === 'function') {\n      if (filterOption !== undefined) {\n        console.warn(\n          'searchOptions prop is being used, filterOption prop will be ignored',\n        );\n      }\n\n      this.searchFunction = searchOptions;\n\n    } else if (typeof filterOption === 'function') {\n  \n      this.searchFunction = (value: string, options: T[]): Mapped[] =>\n      options.filter(o => filterOption(value, o)).map(a => a as any);\n      \n    } else {\n  \n      let mapper: (input: any) => string;\n      if (typeof filterOption === 'string') {\n        mapper = Accessor.generateAccessor(filterOption);\n      } else {\n        mapper = Accessor.IDENTITY_FN;\n      }\n      \n      \n      this.searchFunction = (value: string, options: T[]) => {\n        const fuzzyOpt: FilterOptions<any> = { extract: mapper };\n        return fuzzy\n          .filter(value, options, fuzzyOpt)\n          .map((res: { index: number }) => options[res.index] as any);\n      };\n    }\n\n    return this.searchFunction;\n  }\n\n  private hasHint() {\n    return this.state.searchResults.length > 0 || this.hasCustomValue();\n  }\n}\n\nexport default Typeahead;\n","import * as React from 'react';\nimport classNames from 'classnames';\n\nexport interface Props {\n  className?: string;\n  name?: string;\n  children: React.ReactNode | string;\n  object: string | object;\n  onRemove: Function;\n  value: string;\n  key: string | number;\n}\n\n/**\n * Encapsulates the rendering of an option that has been \"selected\" in a\n * TypeaheadTokenizer\n */ \nclass Token extends React.Component<Props> {\n  \n  render() {\n    const className = classNames([\n      'typeahead-token',\n      this.props.className,\n    ]);\n\n    return (\n      <div className={className} key={this.props.key}>\n        {this.renderHiddenInput()}\n        {this.props.children}\n        {this.renderCloseButton()}\n      </div>\n    );\n  }\n\n  private renderHiddenInput() {\n    const { name, value, object } = this.props;\n    // If no name was set, don't create a hidden input\n    if (!name) {\n      return null;\n    }\n\n    const hiddenValue = value || object;\n    if (typeof hiddenValue !== 'string') {\n      throw new Error('Expected either string value or string object');\n    }\n    return (\n      <input\n        type=\"hidden\"\n        name={name + '[]'}\n        value={hiddenValue}\n      />\n    );\n  }\n\n  renderCloseButton() {\n    if (!this.props.onRemove) {\n      return '';\n    }\n\n    return (\n      <a\n        className={this.props.className || 'typeahead-token-close'} \n        href=\"#\" \n        onClick={(event: React.MouseEvent<HTMLAnchorElement>) => {\n          this.props.onRemove(this.props.object);\n          event.preventDefault();\n        }}\n      >\n        &#x00d7;\n      </a>);\n  }\n}\n\nexport default Token;\n","import * as React from 'react';\nimport bind from 'bind-decorator';\nimport Accessor from '../accessor';\nimport Token from './token';\nimport KeyEvent from '../keyevent';\nimport Typeahead from '../typeahead';\nimport classNames from 'classnames';\nimport { TokenCustomClasses, Option, OptionToStrFn } from '../types';\n\nconst arraysAreDifferent = (array1: any[], array2: any[]): boolean => {\n  if (array1.length !== array2.length) {\n    return true;\n  }\n\n  for (let i = array2.length - 1; i >= 0; i -= 1) {\n    if (array2[i] !== array1[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport interface Props<Opt extends Option> extends React.InputHTMLAttributes<HTMLInputElement> {\n  name?: string;\n  options: Opt[];\n  customClasses?: TokenCustomClasses;\n  allowCustomValues?: number;\n  defaultSelected: any[];\n  initialValue?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  inputProps: object;\n  onTokenRemove?: Function;\n  onTokenAdd?: Function;\n  filterOption?: string | Function;\n  searchOptions?: Function;\n  displayOption?: string | OptionToStrFn<Opt>;\n  formInputOption?: string | OptionToStrFn<Opt>;\n  maxVisible?: number;\n  resultsTruncatedMessage?: string;\n  defaultClassNames?: boolean;\n  showOptionsWhenEmpty?: boolean;\n  innerRef?: (c: HTMLInputElement) => any;\n}\n\nexport interface State<Opt extends Option> {\n  selected: Opt[];\n}\n\n/**\n * A typeahead that, when an option is selected, instead of simply filling\n * the text entry widget, prepends a renderable \"token\", that may be deleted\n * by pressing backspace on the beginning of the line with the keyboard.\n */\nclass TypeaheadTokenizer<T> extends React.Component<Props<T>, State<T>> {\n  constructor(props: Props<T>) {\n    super(props);\n\n    const { defaultSelected = [] } = props;\n    this.state = {\n      // We need to copy this to avoid incorrect sharing\n      // of state across instances (e.g., via getDefaultProps())\n      selected: defaultSelected.slice(0),\n    };\n  }\n\n  private getProps() {\n    const customClasses: TokenCustomClasses = {};\n    return {\n      ...{\n        customClasses,\n        allowCustomValues: 0,\n        disabled: false,\n        inputProps: {},\n        defaultClassNames: true,\n        showOptionsWhenEmpty: false,\n      },\n      ...this.props,\n    };\n  }\n\n  private inputMapper?: OptionToStrFn<T>;\n  private getInputOptionToStringMapper(): OptionToStrFn<T> {\n    if (this.inputMapper) {\n      return this.inputMapper;\n    }\n\n    const { formInputOption, displayOption } = this.getProps();\n    const anyToStrFn = formInputOption || displayOption;\n    this.inputMapper = Accessor.generateOptionToStringFor(anyToStrFn);\n\n    return this.inputMapper;\n  }\n\n  componentWillReceiveProps(nextProps: Props<T>) {\n    // if we get new defaultProps, update selected\n    if (arraysAreDifferent(this.props.defaultSelected, nextProps.defaultSelected)) {\n      this.setState({ selected: nextProps.defaultSelected.slice(0) });\n    }\n  }\n\n  typeaheadElement?: HTMLInputElement;\n  focus() {\n    if (!this.typeaheadElement) throw new Error('No typeahead element');\n    this.typeaheadElement.focus();\n  }\n\n  getSelectedTokens() {\n    return this.state.selected;\n  }\n\n  // TODO: Support initialized tokens\n  //\n  private renderTokens() {\n    const { \n      customClasses: { token }, displayOption, formInputOption, name,\n    } = this.getProps();\n    const tokenClasses: any = {};\n    if (token) tokenClasses[token] = true;\n    const classList: string = classNames(tokenClasses);\n\n    const result = this.state.selected\n      .map((selected) => {\n        const displayString = Accessor.valueForOption(selected, displayOption);\n        const value = Accessor.valueForOption(selected, formInputOption || displayOption);\n        if (!displayString || !value) throw new Error('Expected string and value to exist');\n\n        const key: string = displayString;\n        return (\n          <Token \n            key={key} \n            className={classList}\n            onRemove={this.removeTokenForValue}\n            object={selected}\n            value={value}\n            name={name}\n          >\n            {displayString}\n          </Token>\n        );\n      });\n    return result;\n  }\n\n  private getOptionsForTypeahead() {\n    // return this.props.options without this.selected\n    return this.props.options;\n  }\n\n  @bind\n  private onKeyDown(event: React.KeyboardEvent<HTMLInputElement>) {\n    // We only care about intercepting backspaces\n    if (event.keyCode === KeyEvent.DOM_VK_BACK_SPACE) {\n      return this.handleBackspace(event);\n    }\n    this.props.onKeyDown && this.props.onKeyDown(event);\n  }\n\n  private handleBackspace(event: React.KeyboardEvent<HTMLInputElement>) {\n    // No tokens\n    if (!this.state.selected.length) {\n      return;\n    }\n\n    // Remove token ONLY when bksp pressed at beginning of line\n    // without a selection\n    if (!this.typeaheadElement) throw new Error('Expected typeahead element to exist');\n    if (this.typeaheadElement.selectionStart === this.typeaheadElement.selectionEnd &&\n        this.typeaheadElement.selectionStart === 0) {\n      this.removeTokenForValue(\n        this.state.selected[this.state.selected.length - 1]);\n      event.preventDefault();\n    }\n  }\n\n  private getSelectedIndex(value: T) {\n    const mapper = this.getInputOptionToStringMapper();\n    const searchStr: string = mapper(value);\n    return this.state.selected\n      .map(mapper)\n      .indexOf(searchStr);\n  }\n  private removeTokenForValue(value: T) {\n    const index = this.getSelectedIndex(value);\n    if (index === -1) {\n      return;\n    }\n\n    this.state.selected.splice(index, 1);\n    this.setState({ selected: this.state.selected });\n    this.props.onTokenRemove && this.props.onTokenRemove(value);\n    return;\n  }\n\n  @bind\n  private addTokenForValue(value: T) {\n    let { selected } = this.state;\n    if (this.getSelectedIndex(value) !== -1) {\n      return;\n    }\n    selected = [...selected, value];\n    this.setState({ selected });\n    \n    if (!this.typeaheadElement) throw new Error('Expected typahead to be set');\n\n    this.typeaheadElement.value = '';\n    this.props.onTokenAdd && this.props.onTokenAdd(value);\n  }\n\n  render() {\n    const { \n      className, customClasses = {}, disabled, inputProps,\n      allowCustomValues, initialValue = '',\n      maxVisible, resultsTruncatedMessage, placeholder,\n      onKeyPress, onKeyUp, onFocus, onBlur,\n      showOptionsWhenEmpty, displayOption,\n      defaultClassNames, filterOption,\n      searchOptions,\n    } = this.getProps();\n    const classes: any = {};\n    const { typeahead } = customClasses;\n    if (typeahead) {\n      classes[typeahead] = true;\n    }\n    const classList:any = classNames(classes);\n    const tokenizerClasses: string[] = [];\n    if (defaultClassNames) {\n      tokenizerClasses.push('typeahead-tokenizer');\n    }\n    if (className) {\n      tokenizerClasses.push(className);\n    }\n    const tokenizerClassList = classNames(tokenizerClasses);\n\n    const args2Pass = {\n      placeholder,\n      disabled,\n      inputProps,\n      customClasses,\n      allowCustomValues,\n      initialValue,\n      maxVisible,\n      resultsTruncatedMessage,\n      onKeyPress,\n      onKeyUp,\n      onFocus,\n      onBlur,\n      displayOption,\n      defaultClassNames,\n      filterOption,\n      searchOptions,\n      showOptionsWhenEmpty,\n    };\n\n    return (\n      <div className={tokenizerClassList}>\n        {this.renderTokens()}\n        <Typeahead \n          // @ts-ignore - issue with addTokenForValue!?\n          innerRef={(c: HTMLInputElement) => this.typeaheadElement = c}\n          className={classList}\n          {...args2Pass}\n          options={this.getOptionsForTypeahead()}\n          onOptionSelected={this.addTokenForValue}\n          onKeyDown={this.onKeyDown}\n        />\n      </div>\n    );\n  }\n}\n\nexport default TypeaheadTokenizer;\n"],"names":["constants","bind","target","propertyKey","descriptor","value","typeOfFunction","TypeError","configurable","boolTrue","get","bound","this","Object","defineProperty","writable","exports","Accessor","input","field","object","prop","generateAccessor","selector","Error","hasOwn","hasOwnProperty","classNames","classes","i","arguments","length","arg","argType","push","Array","isArray","apply","key","call","join","module","window","props","_super","_this","onClick","tslib_1.__extends","TypeaheadOption","customClasses","hover","event","preventDefault","_a","children","customValue","listItem","_b","customAdd","Boolean","classList","React.createElement","className","onMouseDown","href","getClasses","typeahead-option","listAnchor","React.Component","TypeaheadSelector","allowCustomValues","onOptionSelected","defaultClassNames","options","displayOption","selectionIndex","areResultsTruncated","resultsTruncatedMessage","typeahead-selector","resClass","customValueComponent","customValueOffset","results","map","result","displayString","resultsTruncatedClasses","results-truncated","resultsTruncated","resultsTruncatedClassList","KeyEvent","DOM_VK_UP","DOM_VK_DOWN","DOM_VK_BACK_SPACE","DOM_VK_RETURN","DOM_VK_ENTER","DOM_VK_ESCAPE","DOM_VK_TAB","fuzzy","simpleFilter","pattern","array","filter","str","test","match","opts","ch","patternIdx","len","totalScore","currScore","pre","post","compareString","caseSensitive","toLowerCase","idx","Infinity","rendered","score","arr","reduce","prev","element","extract","string","index","original","sort","a","b","compare","state","searchResults","getOptionsForValue","initialValue","entryValue","selection","undefined","isFocused","showResults","Typeahead","disabled","textarea","customListComponent","showOptionsWhenEmpty","emptyValue","trim","shouldSkipSearch","generateSearchFunction","searchOptions","getProps","inputElement","onTextEntryUpdated","focus","mapper","getInputOptionToStringMapper","indexOf","hasCustomValue","maxVisible","truncated","slice","getCustomValue","generateOptionToStringFor","inputMapper","displayMapper","option","optionString","formInputOptionString","getDisplayOptionToStringMapper","formInputOption","setState","newValue","getSelection","onKeyDown","events","navUp","navDown","onEnter","onEscape","onTab","delta","hasHint","newIndex","nav","onChange","shiftKey","handler","eventMap","keyCode","nextProps","inputClasses","inputClassList","typeahead","renderHiddenInput","ref","c","innerRef","type","inputProps","placeholder","onKeyPress","onKeyUp","onFocus","onBlur","renderIncrementalSearchResults","name","searchFunction","filterOption","console","warn","o","mapper_1","IDENTITY_FN","res","tslib_1.__decorate","Token","renderCloseButton","hiddenValue","onRemove","selected","TypeaheadTokenizer","array1","array2","arraysAreDifferent","defaultSelected","typeaheadElement","token","tokenClasses","valueForOption","removeTokenForValue","handleBackspace","selectionStart","selectionEnd","searchStr","getSelectedIndex","splice","onTokenRemove","onTokenAdd","_c","tokenizerClasses","tokenizerClassList","args2Pass","renderTokens","getOptionsForTypeahead","addTokenForValue"],"mappings":"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"}